{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _uberproto = require('uberproto');\n\nvar _uberproto2 = _interopRequireDefault(_uberproto);\n\nvar _feathersCommons = require('feathers-commons');\n\nvar _commons = require('./commons');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction isPromise(result) {\n  return typeof result !== 'undefined' && typeof result.then === 'function';\n}\n\nfunction hookMixin(service) {\n  if (typeof service.hooks === 'function') {\n    return;\n  }\n\n  var app = this;\n  var methods = app.methods;\n  var old = {\n    before: service.before,\n    after: service.after\n  };\n  var mixin = (0, _commons.baseMixin)(methods, {\n    before: function before(_before) {\n      return this.hooks({\n        before: _before\n      });\n    },\n    after: function after(_after) {\n      return this.hooks({\n        after: _after\n      });\n    }\n  });\n  (0, _commons.addHookTypes)(service);\n  methods.forEach(function (method) {\n    if (typeof service[method] !== 'function') {\n      return;\n    }\n\n    mixin[method] = function () {\n      var _this = this;\n\n      var service = this; // A reference to the original method\n\n      var _super = this._super.bind(this); // Additional data to add to the hook object\n\n\n      var hookData = {\n        app: app,\n        service: service,\n\n        get path() {\n          return Object.keys(app.services).find(function (path) {\n            return app.services[path] === service;\n          });\n        }\n\n      }; // Create the hook object that gets passed through\n\n      var hookObject = _feathersCommons.hooks.hookObject(method, 'before', arguments, hookData); // Get all hooks\n\n\n      var hooks = {\n        // For before hooks the app hooks will run first\n        before: (0, _commons.getHooks)(app, this, 'before', method),\n        // For after and error hooks the app hooks will run last\n        after: (0, _commons.getHooks)(app, this, 'after', method, true),\n        error: (0, _commons.getHooks)(app, this, 'error', method, true)\n      }; // Process all before hooks\n\n      return _commons.processHooks.call(this, hooks.before, hookObject) // Use the hook object to call the original method\n      .then(function (hookObject) {\n        if (typeof hookObject.result !== 'undefined') {\n          return Promise.resolve(hookObject);\n        }\n\n        return new Promise(function (resolve, reject) {\n          var args = _feathersCommons.hooks.makeArguments(hookObject); // The method may not be normalized yet so we have to handle both\n          // ways, either by callback or by Promise\n\n\n          var callback = function callback(error, result) {\n            if (error) {\n              reject(error);\n            } else {\n              hookObject.result = result;\n              resolve(hookObject);\n            }\n          }; // We replace the callback with resolving the promise\n\n\n          args.splice(args.length - 1, 1, callback);\n\n          var result = _super.apply(undefined, _toConsumableArray(args));\n\n          if (isPromise(result)) {\n            result.then(function (data) {\n              return callback(null, data);\n            }, callback);\n          }\n        });\n      }) // Make a copy of hookObject from `before` hooks and update type\n      .then(function (hookObject) {\n        return Object.assign({}, hookObject, {\n          type: 'after'\n        });\n      }) // Run through all `after` hooks\n      .then(_commons.processHooks.bind(this, hooks.after)) // Finally, return the result\n      .then(function (hookObject) {\n        return hookObject.result;\n      }) // Handle errors\n      .catch(function (error) {\n        var errorHook = Object.assign({}, error.hook || hookObject, {\n          type: 'error',\n          result: null,\n          original: error.hook,\n          error: error\n        });\n        return _commons.processHooks.call(_this, hooks.error, errorHook).then(function (hook) {\n          return hook.result || Promise.reject(hook.error);\n        });\n      });\n    };\n  });\n  service.mixin(mixin); // Before hooks that were registered in the service\n\n  if (old.before) {\n    service.before(old.before);\n  } // After hooks that were registered in the service\n\n\n  if (old.after) {\n    service.after(old.after);\n  }\n}\n\nfunction configure() {\n  return function () {\n    var app = this;\n\n    if (app.version && app.version >= '3.0.0') {\n      throw new Error('You are using Feathers v' + app.version + ' which already includes feathers-hooks. You can remove this module from your application.');\n    }\n\n    (0, _commons.addHookTypes)(app);\n\n    _uberproto2.default.mixin((0, _commons.baseMixin)(app.methods), app);\n\n    this.mixins.unshift(hookMixin);\n  };\n}\n\nexports.default = configure;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}