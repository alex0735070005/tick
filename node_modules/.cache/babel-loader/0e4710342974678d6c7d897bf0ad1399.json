{"ast":null,"code":"var events = require('events');\n\nvar utils = require('./utils');\n\nvar wrap = exports.wrap = {\n  /**\n   * Wrap an anonymous or named function to notify an Emitter and\n   * return the wrapper function.\n   * @param {events.EventEmitter} emitter The emitter to notify\n   * @param {Function} fn The function to wrap\n   * @param {String} name The optional name\n   */\n  fn: function fn(emitter, _fn, strict, name, scope) {\n    var wrapped = function wrapped() {\n      var result;\n      utils.emitEvents(emitter, 'before', name, [arguments, this, name]);\n\n      try {\n        result = _fn.apply(scope || this, arguments);\n      } catch (e) {\n        utils.emitEvents(emitter, 'error', name, [e, arguments, this, name]);\n        throw e;\n      }\n\n      utils.emitEvents(emitter, 'after', name, [result, arguments, this, name]);\n      return result;\n    };\n\n    if (strict) {\n      eval('wrapped = ' + utils.addArgs(wrapped.toString(), _fn.length));\n    }\n\n    return wrapped;\n  },\n\n  /**\n   * Wrap an anonymous or named function that calls a callback asynchronously\n   * to notify an Emitter and return the wrapper function.\n   * @param {events.EventEmitter} emitter The emitter to notify\n   * @param {Function} fn The function to wrap\n   * @param {Integer} position The position of the callback in the arguments\n   * array (defaults to 0). Set to -1 if the callback is the last argument.\n   * @param {String} name The optional name\n   */\n  async: function async(emitter, fn, position, strict, name, scope) {\n    var wrapped = function wrapped() {\n      var pos = position == -1 ? arguments.length - 1 : position || 0;\n      var callback = arguments[pos];\n      var context = this;\n      var methodArgs = arguments;\n\n      var callbackWrapper = function callbackWrapper() {\n        try {\n          callback.apply(context, arguments);\n        } catch (e) {\n          utils.emitEvents(emitter, 'error', name, [e, methodArgs, context, name]);\n          throw e;\n        }\n\n        var eventType = arguments[0] instanceof Error ? 'error' : 'after';\n        utils.emitEvents(emitter, eventType, name, [arguments, methodArgs, context, name]);\n      };\n\n      utils.emitEvents(emitter, 'before', name, [methodArgs, this, name]);\n      methodArgs[pos] = callbackWrapper;\n\n      try {\n        return fn.apply(scope || this, methodArgs);\n      } catch (e) {\n        utils.emitEvents(emitter, 'error', name, [e, methodArgs, context, name]);\n        throw e;\n      }\n    };\n\n    if (strict) {\n      eval('wrapped = ' + utils.addArgs(wrapped.toString(), fn.length));\n    }\n\n    return wrapped;\n  }\n};\n\nvar Emitter = exports.Emitter = function (obj) {\n  this.obj = obj;\n};\n\nEmitter.prototype = Object.create(events.EventEmitter.prototype);\n/**\n * Punch a method with the given name, with\n * @param {String | Array} method The name of the method or a list of\n * method names.\n * @param {Integer} position The optional position of the asynchronous callback\n * in the arguments list.\n */\n\nEmitter.prototype.punch = function (method, position, strict) {\n  if (Array.isArray(method)) {\n    var self = this;\n    method.forEach(function (method) {\n      self.punch(method, position, strict);\n    });\n  } else {\n    var old = this.obj[method];\n\n    if (typeof old == 'function') {\n      this.obj[method] = !position && position !== 0 ? wrap.fn(this, old, strict, method) : wrap.async(this, old, position, strict, method);\n    }\n  }\n\n  return this;\n};\n\nexports.emitter = function (obj) {\n  return new Emitter(obj);\n};","map":null,"metadata":{},"sourceType":"script"}