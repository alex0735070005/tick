{"ast":null,"code":"/* global define */\n\n/**\n * A base object for ECMAScript 5 style prototypal inheritance.\n *\n * @see https://github.com/rauschma/proto-js/\n * @see http://ejohn.org/blog/simple-javascript-inheritance/\n * @see http://uxebu.com/blog/2011/02/23/object-based-inheritance-for-ecmascript-5/\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.Proto = factory();\n  }\n})(this, function () {\n  function makeSuper(_super, old, name, fn) {\n    return function () {\n      var tmp = this._super; // Add a new ._super() method that is the same method\n      // but either pointing to the prototype method\n      // or to the overwritten method\n\n      this._super = typeof old === 'function' ? old : _super[name]; // The method only need to be bound temporarily, so we\n      // remove it when we're done executing\n\n      var ret = fn.apply(this, arguments);\n      this._super = tmp;\n      return ret;\n    };\n  }\n\n  function legacyMixin(prop, obj) {\n    var self = obj || this;\n    var fnTest = /\\b_super\\b/;\n\n    var _super = Object.getPrototypeOf(self) || self.prototype;\n\n    var _old; // Copy the properties over\n\n\n    for (var name in prop) {\n      // store the old function which would be overwritten\n      _old = self[name]; // Check if we're overwriting an existing function\n\n      if ((typeof prop[name] === 'function' && typeof _super[name] === 'function' || typeof _old === 'function' && typeof prop[name] === 'function') && fnTest.test(prop[name])) {\n        self[name] = makeSuper(_super, _old, name, prop[name]);\n      } else {\n        self[name] = prop[name];\n      }\n    }\n\n    return self;\n  }\n\n  function es5Mixin(prop, obj) {\n    var self = obj || this;\n    var fnTest = /\\b_super\\b/;\n\n    var _super = Object.getPrototypeOf(self) || self.prototype;\n\n    var descriptors = {};\n    var proto = prop;\n\n    var processProperty = function processProperty(name) {\n      if (!descriptors[name]) {\n        descriptors[name] = Object.getOwnPropertyDescriptor(proto, name);\n      }\n    }; // Collect all property descriptors\n\n\n    do {\n      Object.getOwnPropertyNames(proto).forEach(processProperty);\n    } while ((proto = Object.getPrototypeOf(proto)) && Object.getPrototypeOf(proto));\n\n    Object.keys(descriptors).forEach(function (name) {\n      var descriptor = descriptors[name];\n\n      if (typeof descriptor.value === 'function' && fnTest.test(descriptor.value)) {\n        descriptor.value = makeSuper(_super, self[name], name, descriptor.value);\n      }\n\n      Object.defineProperty(self, name, descriptor);\n    });\n    return self;\n  }\n\n  return {\n    /**\n     * Create a new object using Object.create. The arguments will be\n     * passed to the new instances init method or to a method name set in\n     * __init.\n     */\n    create: function create() {\n      var instance = Object.create(this);\n      var init = typeof instance.__init === 'string' ? instance.__init : 'init';\n\n      if (typeof instance[init] === 'function') {\n        instance[init].apply(instance, arguments);\n      }\n\n      return instance;\n    },\n\n    /**\n     * Mixin a given set of properties\n     * @param prop The properties to mix in\n     * @param obj [optional] The object to add the mixin\n     */\n    mixin: typeof Object.defineProperty === 'function' ? es5Mixin : legacyMixin,\n\n    /**\n     * Extend the current or a given object with the given property\n     * and return the extended object.\n     * @param prop The properties to extend with\n     * @param obj [optional] The object to extend from\n     * @returns The extended object\n     */\n    extend: function extend(prop, obj) {\n      return this.mixin(prop, Object.create(obj || this));\n    },\n\n    /**\n     * Return a callback function with this set to the current or a given context object.\n     * @param name Name of the method to proxy\n     * @param args... [optional] Arguments to use for partial application\n     */\n    proxy: function proxy(name) {\n      var fn = this[name];\n      var args = Array.prototype.slice.call(arguments, 1);\n      args.unshift(this);\n      return fn.bind.apply(fn, args);\n    }\n  };\n});","map":null,"metadata":{},"sourceType":"script"}